# Copyright 2017 The Wazo Authors  (see the AUTHORS file)
# SPDX-License-Identifier: GPL-3.0-or-later

import logging
import kombu
import kombu.mixins

from collections import deque
from contextlib import contextmanager

logger = logging.getLogger(__name__)


class CoreBusConsumer(kombu.mixins.ConsumerMixin):

    def __init__(self, global_config):
        self._is_running = False
        self.connection = None

        self._bus_url = 'amqp://{username}:{password}@{host}:{port}//'.format(**global_config['bus'])
        self._upstream_exchange = kombu.Exchange(global_config['bus']['exchange_name'],
                                                 type=global_config['bus']['exchange_type'])
        self._exchange = kombu.Exchange(global_config['bus']['exchange_headers_name'],
                                        type='headers')
        self._consumers = {}
        self._new_consumers = deque()
        self._stale_consumers = deque()
        self._updated_consumers = deque()

    def run(self):
        logger.info("Running bus consumer")
        with kombu.Connection(self._bus_url) as connection:
            self.connection = connection

            super(CoreBusConsumer, self).run()

    def get_consumers(self, Consumer, channel):
        for consumer in self._consumers.values():
            self._reset_queue_names(consumer)
            consumer.revive(channel)
        return self._consumers.values()

    def _reset_queue_names(self, consumer):
        '''When reconnecting, the old autogenerated queue does not exist,
        and we can't use the autogenerated name to declare a new queue.
        '''
        for queue_ in consumer.queues:
            queue_.name = None

    def on_connection_error(self, exc, interval):
        super(CoreBusConsumer, self).on_connection_error(exc, interval)
        for consumer in self._consumers:
            try:
                consumer.cancel()
            except Exception:
                pass
        self._is_running = False

    def on_connection_revived(self):
        super(CoreBusConsumer, self).on_connection_revived()
        self._is_running = True

    @contextmanager
    def extra_context(self, connection, channel):
        self._active_connection = connection
        self._upstream_exchange.bind(connection).declare()
        exchange = self._exchange.bind(connection)
        exchange.declare()
        exchange.bind_to(self._upstream_exchange, routing_key='#')
        yield

    def on_iteration(self):
        while self._new_consumers:
            uuid, consumer = self._new_consumers.pop()
            logger.debug('Adding consumer (uuid: %s)', uuid)
            consumer.revive(self._active_connection)
            consumer.consume()
            self._consumers[uuid] = consumer

        while self._updated_consumers:
            uuid, new_consumer = self._updated_consumers.pop()
            logger.debug('Changing consumer binding (uuid: %s)', uuid)
            try:
                old_consumer = self._consumers[uuid]
            except KeyError:
                logger.error('%s: consumer not found')
                continue

            new_consumer.revive(self._active_connection)
            new_consumer.consume()
            old_consumer.cancel()
            self._consumers[uuid] = new_consumer

        while self._stale_consumers:
            uuid = self._stale_consumers.pop()
            logger.debug('Removing consumer (uuid: %s)', uuid)
            try:
                consumer = self._consumers.pop(uuid)
            except KeyError:
                logger.warning('Tried to remove unknown consumer (uuid: %s)', uuid)
                continue

            consumer.cancel()

    def is_running(self):
        return self._is_running

    def subscribe_to_event_names(self, uuid, event_names, user_uuid, wazo_uuid, callback):
        if uuid is None:
            raise RuntimeError("uuid must be set")
        elif not event_names:
            raise RuntimeError("event_names must be set")
        logger.debug('Subscribing new callback to events %s (uuid: %s)', event_names, uuid)
        queue = kombu.Queue(exclusive=True, bindings=self._create_bindings(event_names, user_uuid, wazo_uuid))
        consumer = kombu.Consumer(channel=None, queues=queue, callbacks=[callback])
        self._new_consumers.append((uuid, consumer))

    def change_subscription(self, uuid, event_names, user_uuid, wazo_uuid, callback):
        if uuid is None:
            raise RuntimeError("uuid must be set")
        elif not event_names:
            raise RuntimeError("event_names must be set")
        logger.debug('Changing subscription for callback (uuid: %s)', uuid)
        queue = kombu.Queue(exclusive=True, bindings=self._create_bindings(event_names, user_uuid, wazo_uuid))
        consumer = kombu.Consumer(channel=None, queues=queue, callbacks=[callback])
        self._updated_consumers.append((uuid, consumer))

    def unsubscribe_from_event_names(self, uuid):
        if uuid is None:
            raise RuntimeError("uuid must be set")
        logger.debug('Unsubscribing callback (uuid: %s)', uuid)
        self._stale_consumers.append(uuid)

    def _create_bindings(self, event_names, user_uuid, wazo_uuid):
        result = []
        for name in event_names:
            arguments = {
                'x-match': 'all',
                'name': name,
            }
            if user_uuid:
                arguments['user_uuid:{uuid}'.format(uuid=user_uuid)] = True
            if wazo_uuid:
                arguments['origin_uuid'] = wazo_uuid

            binding = kombu.binding(exchange=self._exchange,
                                    arguments=arguments,
                                    unbind_arguments=arguments)
            result.append(binding)

        return result
