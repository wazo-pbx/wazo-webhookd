# Copyright 2017-2021 The Wazo Authors  (see the AUTHORS file)
# SPDX-License-Identifier: GPL-3.0-or-later

import logging
import kombu
import kombu.mixins

from contextlib import contextmanager
from functools import partial
from queue import Queue

logger = logging.getLogger(__name__)


class CoreBusConsumer(kombu.mixins.ConsumerMixin):
    def __init__(self, global_config):
        self._is_running = False
        self.connection = None

        self._bus_url = 'amqp://{username}:{password}@{host}:{port}//'.format(
            **global_config['bus']
        )
        self._exchange = kombu.Exchange(
            global_config['bus']['exchange_name'],
            type=global_config['bus']['exchange_type'],
        )
        self._consumers = {}
        self._consumer_updates = Queue()

    def run(self):
        logger.info("Running bus consumer")
        with kombu.Connection(self._bus_url) as connection:
            self.connection = connection

            super().run()

    def get_consumers(self, Consumer, channel):
        for consumer in self._consumers.values():
            self._reset_queue_names(consumer)
            consumer.revive(channel)
        return self._consumers.values()

    def _reset_queue_names(self, consumer):
        """When reconnecting, the old autogenerated queue does not exist,
        and we can't use the autogenerated name to declare a new queue.
        """
        for queue_ in consumer.queues:
            queue_.name = None

    def on_connection_error(self, exc, interval):
        super().on_connection_error(exc, interval)
        for consumer in self._consumers:
            try:
                consumer.cancel()
            except Exception:
                pass
        self._is_running = False

    def on_connection_revived(self):
        super().on_connection_revived()
        self._is_running = True

    @contextmanager
    def extra_context(self, connection, channel):
        self._active_connection = connection
        yield

    def on_iteration(self):
        while not self._consumer_updates.empty():
            update = self._consumer_updates.get_nowait()
            update()

    def _add_consumer(self, uuid, consumer):
        logger.debug('Adding consumer (uuid: %s)', uuid)
        consumer.revive(self._active_connection)
        consumer.consume()
        self._consumers[uuid] = consumer

    def _update_consumer(self, uuid, new_consumer):
        logger.debug('Changing consumer binding (uuid: %s)', uuid)
        try:
            old_consumer = self._consumers[uuid]
        except KeyError:
            logger.error('%s: consumer not found')
            return

        new_consumer.revive(self._active_connection)
        new_consumer.consume()
        old_consumer.cancel()
        self._consumers[uuid] = new_consumer

    def _remove_consumer(self, uuid):
        logger.debug('Removing consumer (uuid: %s)', uuid)
        try:
            consumer = self._consumers.pop(uuid)
        except KeyError:
            logger.warning('Tried to remove unknown consumer (uuid: %s)', uuid)
            return

        consumer.cancel()

    def is_running(self):
        return self._is_running

    def subscribe_to_event_names(
        self, uuid, event_names, user_uuid, wazo_uuid, callback
    ):
        if uuid is None:
            raise RuntimeError("uuid must be set")
        elif not event_names:
            logger.warning("subscription `%s` doesn't have event_names set", uuid)
            return

        logger.debug(
            'Subscribing new callback to events %s (uuid: %s)', event_names, uuid
        )
        queue = kombu.Queue(
            exclusive=True,
            bindings=self._create_bindings(event_names, user_uuid, wazo_uuid),
        )
        callback = partial(self._on_bus_message, callback)
        consumer = kombu.Consumer(channel=None, queues=queue, callbacks=[callback])
        self._consumer_updates.put(partial(self._add_consumer, uuid, consumer))

    def change_subscription(self, uuid, event_names, user_uuid, wazo_uuid, callback):
        if uuid is None:
            raise RuntimeError("uuid must be set")
        elif not event_names:
            logger.warning("subscription `%s` doesn't have event_names set", uuid)
            return

        logger.debug('Changing subscription for callback (uuid: %s)', uuid)
        queue = kombu.Queue(
            exclusive=True,
            bindings=self._create_bindings(event_names, user_uuid, wazo_uuid),
        )
        callback = partial(self._on_bus_message, callback)
        consumer = kombu.Consumer(channel=None, queues=queue, callbacks=[callback])
        self._consumer_updates.put(partial(self._update_consumer, uuid, consumer))

    def unsubscribe_from_event_names(self, uuid):
        if uuid is None:
            raise RuntimeError("uuid must be set")

        logger.debug('Unsubscribing callback (uuid: %s)', uuid)
        self._consumer_updates.put(partial(self._remove_consumer, uuid))

    def _create_bindings(self, event_names, user_uuid, wazo_uuid):
        result = []
        for name in event_names:
            arguments = {'x-match': 'all', 'name': name}
            if user_uuid:
                arguments['user_uuid:{uuid}'.format(uuid=user_uuid)] = True
            if wazo_uuid:
                arguments['origin_uuid'] = wazo_uuid

            binding = kombu.binding(
                exchange=self._exchange, arguments=arguments, unbind_arguments=arguments
            )
            result.append(binding)

        return result

    @staticmethod
    def _on_bus_message(callback, body, message):
        logger.debug('running callback %s', callback)
        try:
            callback(body, message)
        except Exception:
            logger.exception('Consumer callback exception')
        finally:
            message.ack()
